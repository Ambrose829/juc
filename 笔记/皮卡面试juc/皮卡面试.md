# Volatile是什么？

## 1.volatile是java虚拟机提供的轻量级的同步机制
* 保证可见性

  > 

* 不保证原子性

  > 解决方法
  >
  > > 加synchronized关键字
  > >
  > > java.util.concurrent.atomic中的原子类
  >
  > 

* 禁止指令重排序

  > volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象
  >
  > 先了解一个概念，内存屏障（Memory Barrier）又称内存栈栏，是一个CPU指令，它的作用有两个：
  >
  > 一是保证特定操作的执行顺序
  >
  > 二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）

  由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说 **通过插入内存屏障禁止在内存屏障前后的指令执行重排序优化**。内存屏障另外一个作用就是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。

  

  对volatile变量进行写操作时，会在写操作后加入一条store屏障指令，将工作内存中的共享变量的值刷回到主内存

  ![image-20200923191835531](.\images\image-20200923191835531.png)	 

  对volatile变量进行读操作时，会在读操作前加入一条load屏障指令，从主内存中读取共享变量

  ![image-20200923191907325](.\images\image-20200923191907325.png) 

## 2.谈谈JMM（java内存模型）

JMM（Java内存模型Java Memory Model,简称JMM）本身是一种抽象概念并不真实存在，它描述的是一组规则或规范，通过这组规范定义了程序中各个变量（包括实例字段，静态字段和构成数组对象的元素）的访问方式。



JMM关于同步的规定：

* 线程解锁前，必须把共享变量的值刷新回主内存
* 线程加锁前，必须读取主内存中最新值到自己的工作内存
* 加锁解锁是同一把锁



由于JVM运行程序的实体是线程，而每个线程创建时JVM都会为其创建一个工作内存（有些地方称为栈空间），工作内存是每个线程的私有数据区域，而Java内存模型中规定所有变量都存储在主内存，主内存是共享内存区域，所有线程都可以访问，**但线程对变量的操作（读取赋值等）必须在工作内存中进行，首先要将变量从主内存中拷贝到工作内存中，然后在工作内存中对变量进行操作，操作完成后再将变量写回主内存**，不能直接操作主内存中的变量，各个线程中的工作内存中存储着主内存中的变量副本拷贝，因此不同的线程间无法访问对方的工作内存，线程间通信（传值）必须通过主内存来完成，其简要访问过程如下图：

![image-20200922200006156](.\images\image-20200922200006156.png) 





## 可见性

> 问题：
>
> > 各个线程对对主内存的操作都是各个线程各自拷贝到自己的工作内存进行操作后再写回到主内存中的。
> >
> > 这就是一个线程A修改了主内存中共享变量x的值但还未写回主内存时，另外一个线程B又对主内存中的同一个共享变量x进行操作，但此时，线程A工作内存中的共享变量x对于线程B不可见，这种工作内存与主内存同步延迟现象就造成了可见性问题。
>
> 可以添加volatile关键字保证**线程可见性**
>
> 

## 原子性	

n++这种操作在虚拟机中被分成三步

![image-20200923103558516](.\images\image-20200923103558516.png) 

number++在多线程下是非线程安全的，如何不加sychronized解决？

> java.util.concurrent.atomic中的原子类





##  VolatileDemo代码演示可见性+原子性代码	



## 有序性

> 计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分以下三种

![image-20200923174738172](.\images\image-20200923174738172.png) 

> 单线程环境里面确保程序最终执行结果和代码顺序执行的结果一致。
>
> 处理器在进行重排序时必须要考虑指令间的数据依赖性。
>
> 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中变量能否保证一致性是无法确定的，结果无法预测。

## 线程安全性得到保证

## 3.你在哪些地方用到过volatile？

### 单例模式DCL代码



```java
package com.pika.singleton;

/**
 * @author Pika
 * @create 2020/9/23
 * @since 1.0.0
 */
public class SingletonDemo {
    private static SingletonDemo instance = null;
    private SingletonDemo() {
        System.out.println(Thread.currentThread().getName() + "\t 构造方法");
    }

    //双端检索机制
    private static  SingletonDemo getInstance() {
        if (instance == null) {
            synchronized (SingletonDemo.class) {
                if (instance == null) {
                    instance = new SingletonDemo();
                }
            }
        }
        return instance;
    }


    public static void main(String[] args) {
        for (int i = 1; i <= 10; i++) {
            new Thread(() -> {
                SingletonDemo.getInstance();
            }, String.valueOf(i)).start();
        }
    }
}

```



### 单例模式volatile分析

> DCL（双端检锁）机制不一定安全，原因是有指令重排序的存在，加入volatile可以禁止指令重排序
>
> 原因在于某一个线程执行到第一次检测，读取到的instance不为null时，instance的引用对象可能没有完成初始化。
>
> instance = new SingletonDemo();可以分为以下三步完成（伪代码）
>
> memory = allocate(); //1.分配对象内存空间
>
> instance(memory); //2.初始化对象
>
> instance = memory; //3.设置instance指向刚分配的内存地址，此时instance != null
>
> 
>
> 步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单线程中并没有改变，
>
> 因此这种重排优化是允许的。
>
> memory = allocate(); //1.分配对象内存空间
>
> instance = memory； //3.设置instance指向刚分配的内存地址，此时instance != null,但是对象还没有初始化完成！
>
> instance(memory); //2.初始化对象
>
> 但是指令重排只会保证串行语义的执行的一致性（单线程），但并不会关心多线程间语义一致性。
>
> 所以当一条线程访问instance不为null时，由于instance实例未必已初始化完成，也就造成了线程安全问题。



# CAS知道吗？

## 比较并交换

compareAndSet，判断内存中的值和期望中的值是否相同，相同则更新，不同则放弃之前的操作，重新从内存中获取值



## CAS底层原理？如果知道，谈谈你对Unsafe的理解

自旋锁+unsafe类



### atomicInteger

```java
public final boolean compareAndSet(int expect, int update) {
        return unsafe.compareAndSwapInt(this, valueOffset, expect, update);
    	//unsafe.compareAndSwapInt(当前对象, 内存偏移量（内存地址）, 期待值, 修改值);
    }


```

unsafe类是什么？

![image-20200924152740626](.\images\image-20200924152740626.png) 

### Unsafe

> 1Unsafe
>
> Unsafe是CAS的核心类，由于Java方法无法直接访问底层系统，需要通过调用本地（native）方法来访问，Unsafe相当于一个后门，基于该类可以直接操作特定内存的数据。Unsafe类存在于sun.misc包中，其内部方法操作可以向C的指针一样直接操作内存，因为Java中CAS操作的执行依赖于Unsafe方法。
>
> **注意Unsafe类中的所有方法都是native修饰的，也就是说Unsafe类中的方法都直接调用操作系统底层资源执行相应任务。**
>
> 
>
> 2变量valueOffset，表示该变量值在内存中的偏移地址，因为Unsafe就是根据内存偏移地址获取数据的。
>
> 
>
> 3变量value用volatile修饰，保证了多线程之间的内存可见性。



### CAS是什么

> CAS的全称是Compare And Swap，**它是一条CPU并发原语**。
>
> 它的功能是判断内存中某个位置的值是否为预期值，如果是则修改为新的值，这个过程是原子的。
>
> 
>
> CAS并发原语体现在java就是sun.misc.Unsafe类中的各个方法。调用Unsafe类的CAS方法，JVM会帮我们实现出CAS汇编指令，是一种完全依赖于硬件的功能，通过它实现了原子操作。再次强调，由于CAS是一种系统原语，原语属于操作系统用语范畴，是若干条指令组成的，用于完成某个功能的一个过程，**并且原语的执行是连续的，在执行过程中允许被打断，也就是CAS是一条CPU的原子命令，不会造成所谓的数据不一致问题。**



**unsafe.getAndAddInt()**

![image-20200924155142758](.\images\image-20200924155142758.png) 

![image-20200924155206924](.\images\image-20200924155206924.png)



> var1	AtomicInteger对象本身
>
> var2	该对象的引用地址
>
> var4	是每次递增的步数
>
> var5	是通过var1和var2从内存中找到的真实值。用该对象和当前的值和var5相比较，如果相同，将值更新为var5+var4并且返回true，如果不同，则继续取值然后再比较，直到更新完成 



> 假设线程A和线程B两个线程同时执行getAndAddInt操作（分别跑在不同的CPU上）：
>
> 
>
> 1	AtomicInteger里面的value原始值为3，即主内存中AtomicInteger的value为3，根据JMM模型，线程A和线程B各自持有一份值为3的value副本分别到各自的工作内存。
>
> 2	线程A通过getIntVolatile(var1, var2)拿到value值3，这时线程A被挂起。
>
> 3	线程B也通过getIntVolatile(var1, var2)方法获取到value值3，此时刚好线程B没有被挂起并执行compareAndSwapInt方法比较内存值也为3，成功修改内存值为4，线程B打完收工，一切OK。
>
> 4	这时线程A恢复，执行compareAndSwapInt方法比较，发现自己手里的值数字3和主存的值4不一致，说明该值已经被其它线程抢先一步修改过了，那A线程本次修改失败，只能重新来一遍了。
>
> 5	线程A重新获取value值，因为变量value被volatile修饰，所以其他线程对它的修改，线程A总是能够看到，线程A继续执行compareAndSwapInt进行比较替换，直到成功。



**底层汇编**

> Unsafe类中的compareAndSwapInt，是一个本地方法，该方法的实现位于unsafe.cpp中
>
> > 先想办法拿到变量value在内存中的地址。
> >
> > 通过(Atomic::cmpxchg(x,addr,e))==e实现比较替换，其中参数x是即将更新的值，参数e是原内存的值.



### 小总结

CAS(CompareAndSwap)

比较当前工作内存中的值和主内存中的值，如果相同则执行规定操作，否则继续比较直到主内存和工作内存中的值一样为止



CAS应用

CAS有三个操作数，内存值V，旧的预期值A，要修改的更新值B。

当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。



## CAS的缺点

* 循环时间长开销很大

  > 我们可以看到getAndAddInt方法执行时，有个doWhile
  >
  > ![image-20200924155206924](.\images\image-20200924155206924.png)
  >
  > 如果CAS失败，会一直进行尝试。如果CAS一直不成功，会给CPU带来很大的开销。

* 只能保证一个共享变量的原子操作

  > 当对一个共享变量进行操作时，我们可以使用循环CAS的方式来保证原子操作
  >
  > 
  >
  > 但是，对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁来保证原子性。

* 引出来ABA问题

  > 线程1想将将值A变为其它值，但是它比较慢，线程2特别快，在线程1没来得及将自己的值和主内存比较时，它已经将值A改为B又改为A了，这时线程1将值与内存的值比较，相同，于是它就修改了。

  

  > CAS算法实现一个重要前提是需要取出内存中某时刻的数据与当下时刻比较并替换，那么在这个时间差内可能会有数据的变化。
  >
  > 比如说一个线程T1从内存的位置V中取出A，这时候另一个线程T2也从内存中取出A，并且线程T2进行了一些操作将值变为B，然后线程T2又将V位置的数据变为A，这时线程T1进行CAS操作发现内存中仍然是A，然后线程A操作成功。
  >
  > **尽管线程T1的操作是成功的，但是不代表整个过程是没有问题的 **
  
  
  
  
  
  

### 使用原子引用解决ABA问题



#### AtomicReference原子引用

如果想对某个类进行原子包装，使用AtomicReference类进行包装

```java
package com.pika.cas;

import lombok.AllArgsConstructor;
import lombok.Data;

import java.util.concurrent.atomic.AtomicReference;

/**
 * @author Pika
 * @create 2020/9/24
 * @since 1.0.0
 */
public class AtomicReferenceDemo {
    public static void main(String[] args) {
        AtomicReference<User> userAtomicReference = new AtomicReference<>();

        User z3 = new User("z3", 22);
        User l4 = new User("l4", 25);

        userAtomicReference.set(z3);

        System.out.println(userAtomicReference.compareAndSet(z3, l4) + "\t" + userAtomicReference.get().toString());
        System.out.println(userAtomicReference.compareAndSet(z3, l4) + "\t" + userAtomicReference.get().toString());


    }
}
@Data
@AllArgsConstructor
class User {
    String userName;
    int age;
}

```



#### 解决ABA问题

使用带有版本号（时间戳）的原子引用`AtomicStampedReference`

```java
package com.pika.cas;

import com.sun.org.apache.xml.internal.serializer.ToTextSAXHandler;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.atomic.AtomicStampedReference;

import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * @author Pika
 * @create 2020/9/27
 * @since 1.0.0
 */
public class AtomicStampedReferenceDemo {
    static AtomicReference atomicReference = new AtomicReference<Integer>(100);

    static AtomicStampedReference<Integer> atomicStampedReference =
            new AtomicStampedReference<Integer>(100, 1);
    public static void main(String[] args) {
        System.out.println("======================ABA问题的产生");
        new Thread(() -> {
            atomicReference.compareAndSet(100, 101);
            atomicReference.compareAndSet(101, 100);
        }, "T1").start();

        new Thread(() -> {
            //暂停1秒钟线程，保证上面的T1完成了一次ABA操作
            try { SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
            System.out.println(atomicReference.compareAndSet(100, 2019) +
                    "\t " + atomicReference.get());
        }, "T2").start();


        try { SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
        System.out.println("======================ABA问题的解决");

        new Thread(() -> {

            System.out.println(Thread.currentThread().getName() + "\t第1次版本号：" + 
                    atomicStampedReference.getStamp());
            //暂停1秒钟T3线程，确保T4线程获取同样的版本号
            try { SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
            atomicStampedReference.compareAndSet(100, 101,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
            System.out.println(Thread.currentThread().getName() + "\t第2次版本号：" + 
                    atomicStampedReference.getStamp());
            atomicStampedReference.compareAndSet(101, 100,
                    atomicStampedReference.getStamp(), atomicStampedReference.getStamp() + 1);
            System.out.println(Thread.currentThread().getName() + "\t第3次版本号：" + 
                    atomicStampedReference.getStamp());

        }, "T3").start();

        new Thread(() -> {
            int stamp = atomicStampedReference.getStamp();
            System.out.println(Thread.currentThread().getName() + "\t第1次版本号：" + stamp);
            //暂停3秒钟T4线程
            try { SECONDS.sleep(3); } catch (InterruptedException e) { e.printStackTrace(); }
            boolean bl = atomicStampedReference.compareAndSet(100, 2019,
                    stamp, stamp + 1);
            System.out.println(Thread.currentThread().getName() + "\t修改成功/否：" + bl + "\t当前最新版本号" +
                    atomicStampedReference.getStamp());
            System.out.println(Thread.currentThread().getName() + "\t当前实际最新值" + 
                    atomicStampedReference.getReference());
        }, "T4").start();
    }
}

```





## Volatile 和 Synchronized比较

> volatile
>
> > 没有加锁，并发性大大提高，但是如果cas失败，会一直尝试，会给CPU带来很大的开销。
> >
> > 
> >
> > 只能保证一个共享变量的原子操作
> >
> > 
> >
> > 会有ABA问题
>
> 
>
> synchronized
>
> > 加锁，并发性下降，来一个解决一个
> >
> > 
> >
> > 可以保证多个共享变量的原子操作





# 集合类不安全

## List不安全

```java
private static void listNotSafe() {
//        List<String> list = new ArrayList<>();
//        List<String> list = new Vector<>();
//        List<String> list = Collections.synchronizedList(new ArrayList<>());

        List<String> list = new CopyOnWriteArrayList<>();


        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                list.add(UUID.randomUUID().toString().substring(0,8));
                System.out.println(list);
            }, String.valueOf(i)).start();
        }
        /**
         * 故障现象
         * java.util.ConcurrentModificationException
         *
         * 导致原因
         *  并发争抢修改导致的：一个线程正在修改，另一个线程也想要修改并过来抢夺，导致数据不一致，并发修改异常。
         * 解决方案
         *  1.List<String> list = new Vector();
         *
         *  2.List<String> list = Collections.synchronizedList(new ArrayList<>());
         *
         *  3.List<String> list = new CopyOnWriteArrayList();
         *      写时复制
         *      CopyOnWrite容器即写时复制容器。往一个容器添加元素的时候，不直接往当前容器Object[]中添加，而是先拷贝当前容器Object[]，
         *      复制出一个新的容器Object[] newElements，然后在新的新的容器newElements中添加元素，添加完元素后，
         *      将原容器的引用指向新的容器setArray(newElements); 这样做的好处是可以对CopyOnWrite进行并发的读，
         *      而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite也是一种读写分离的思想，读和写在不同的容器中。
         *
         *      public boolean add(E e) {
         *         final ReentrantLock lock = this.lock;
         *         lock.lock();
         *         try {
         *             Object[] elements = getArray();
         *             int len = elements.length;
         *             Object[] newElements = Arrays.copyOf(elements, len + 1);
         *             newElements[len] = e;
         *             setArray(newElements);
         *             return true;
         *         } finally {
         *             lock.unlock();
         *         }
         *     }
         * 优化建议
         */
    }
```



## Set不安全

```java
private static void setNotSafe() {
//        Set<String> set = new HashSet<>();
//        Set<String> set = Collections.synchronizedSet(new HashSet<>());
        Set<String> set = new CopyOnWriteArraySet<>();

        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                set.add(UUID.randomUUID().toString().substring(0, 8));
                System.out.println(set);
            }, String.valueOf(i)).start();

        }
    }
```



## Map不安全

```java
private static void mapNotSafe() {
        //        Map<String, String> map = new HashMap<>();
//        Map<String, String> map = new Hashtable<>();
//        Map<String, String> map = Collections.synchronizedMap(new HashMap<>());
        Map<String, String> map = new ConcurrentHashMap<>();

        for (int i = 1; i <= 30; i++) {
            new Thread(() -> {
                map.put(Thread.currentThread().getName(), UUID.randomUUID().toString().substring(0, 8));
                System.out.println(map);
            }, String.valueOf(i)).start();
        }
    }
```



# Java锁

## 公平锁/非公平锁

### 是什么

> 公平锁： 指多个线程按照申请锁的顺序来获取锁，类似于队列，先来后到。
>
> 
>
> 非公平锁：是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁，在高并发的情况下，有可能会造成优先级反转或饥饿的现象。

### 两者区别

> 并发包中的ReentrantLock的创建可以指定构造函数中的布尔类型来得到公平锁(true)和非公平锁(false)，默认为非公平锁
>
> 
>
> 关于两者区别
>
> 公平锁： 公平锁就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列的第一个，就占有锁，否则旧会加入到等待队列中，以后会按照FIFO的规则从队列中取到自己
>
> 非公平锁：非公平锁就是很粗鲁，上来就先尝试占有锁，如果尝试获取锁失败，就再采用公平锁那种方式。

### 补充

> 对于ReentrantLock而言，
>
> 通过默认构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点是吞吐量比公平锁大。
>
> 对于synchronized而言，也是一种非公平锁。

## 可重入锁（递归锁）

### 是什么

> 指的是同一个线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，
>
> 在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，
>
> 也即是说 ，线程可以进入任何一个它已经拥有的锁所同步着的代码块。



### ReentrantLock/synchronized就是典型的可重入锁

```java
package com.pika.lock;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author Pika
 * @create 2020/9/27
 * @since 1.0.0
 * 可重入锁（递归锁）
 * 指的是同一个线程外层函数获得锁之后，内层递归函数仍然能获取该锁的代码，
 * 在同一个线程在外层方法获取锁的时候，在进入内层方法会自动获取锁，
 * 也即是说 ，线程可以进入任何一个它已经拥有的锁所同步着的代码块
 */
public class ReetrantLockDemo {
    public static void main(String[] args) {
        IPhone phone = new IPhone();
        new Thread(()->{
            phone.sms();
        },"T1").start();

        new Thread(()->{
            phone.sms();
        },"T2").start();

        try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
        System.out.println();
        System.out.println();
        System.out.println();
        
        Thread t3 = new Thread(phone);
        Thread t4 = new Thread(phone);
        t3.start();
        t4.start();

    }
}

class IPhone implements Runnable{
        Lock lock = new ReentrantLock();

    public synchronized void sms() {
        System.out.println(Thread.currentThread().getName() + "sms");
        call();
    }

    public synchronized void call() {
        System.out.println(Thread.currentThread().getName() + "call");

    }

    @Override
    public void run() {
        get();
    }

    public void get() {
        lock.lock();
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "调用get()");
            set();
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
            lock.unlock();
        }

    }
    public void set() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "调用set()");
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }

    }


}
```



## 自旋锁

> 是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式去尝试获取锁，这样的好处是减少了线程上下文切换的消耗，缺点是循环会消耗CPU

```java
package com.pika.lock;

import java.util.concurrent.atomic.AtomicReference;

public class SpinLockDemo {
    AtomicReference<Thread> atomicReference = new AtomicReference<Thread>();

    public void myLock() {
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName() + "myLock()");
        do {

        }while (!atomicReference.compareAndSet(null, thread));
    }

    public void myUnLock() {
        Thread thread = Thread.currentThread();
        System.out.println(thread.getName() + "myUnLock()");
        atomicReference.compareAndSet(thread, null);
    }

}

```





```java
package com.pika.lock;

import java.util.concurrent.TimeUnit;

public class TestSpinLockDemo {
    public static void main(String[] args) throws InterruptedException {
        SpinLockDemo lock = new SpinLockDemo();

        new Thread(()->{
            lock.myLock();
            try {
                TimeUnit.SECONDS.sleep(3);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.myUnLock();
            }
        }, "T1").start();


        TimeUnit.SECONDS.sleep(1);

        new Thread(()->{
            lock.myLock();
            try {
//                TimeUnit.SECONDS.sleep(1);
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.myUnLock();
            }
        }, "T2").start();
    }
}

```



## 独占锁(写锁)/共享锁(读锁)/互斥锁

> 多个线程同时读一个资源没有问题，所以为了满足并发量，读取共享资源可以同时进行。
>
> 但是，如果有一个线程去写共享资源，就不应该再有其它线程可以对该资源进行读或写
>
> 小总结：
>
> > 读读共存
> >
> > 读写不能共存
> >
> > 写写不能共存
>
> ​	



```java
package com.pika.lock;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

/**
 * @author Pika
 * @create 2020/9/27
 * @since 1.0.0
 *
 * 多个线程同时读一个资源没有问题，所以为了满足并发量，读取共享资源可以同时进行。
 * 但是，如果有一个线程去写共享资源，就不应该再有其它线程可以对该资源进行读或写
 * 小总结：
 *  读读共存
 *  读写不能共存
 *  写写不能共存
 *
 *  写操作：原子+独占，整个过程必须是一个完整的统一的整体，中间不许被分割，被打断
 *  读操作：共享
 *
 */
public class ReadWriteLockDemo {
    public static void main(String[] args) {
        MyCache myCache = new MyCache();
        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCache.put(tempInt + "", tempInt + "");
            }, String.valueOf(i)).start();
        }

        for (int i = 1; i <= 5; i++) {
            final int tempInt = i;
            new Thread(() -> {
                myCache.get(tempInt + "");
            }, String.valueOf(i)).start();
        }


    }
}

class MyCache {
    private volatile Map<String, Object> map = new HashMap<>();
    private ReadWriteLock rwLock = new ReentrantReadWriteLock();

    public void put(String key, Object value) {

        rwLock.writeLock().lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t 正在写入" + key);
            try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }
            map.put(key, value);
            System.out.println(Thread.currentThread().getName() + "\t 写入完成");
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            rwLock.writeLock().unlock();
        }

    }

    public Object get(String key) {
        rwLock.readLock().lock();
        try {

        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            rwLock.readLock().unlock();
        }

        System.out.println(Thread.currentThread().getName() + "\t 正在读取" + key);
        try { TimeUnit.MILLISECONDS.sleep(300); } catch (InterruptedException e) { e.printStackTrace(); }
        Object result = map.get(key);
        System.out.println(Thread.currentThread().getName() + "\t读取完成" + result);
        return result;
    }
}
```



# 辅助类

## CountDownLatch

> 让一些线程阻塞直到另一些线程完成一系列操作后才被唤醒
>
> 
>
> 原理：
>
> `countDownLatch.countDown();`//数量减一
>
> `countDownLatch.await();`//等待计数器归零，然后再向下执行
>
> 每次有线程调用countDown(),countDownLatch中的数量减一，假设计数器变为0，countDownLatch.await();就会被唤醒，继续执行





```java
package com.pika.add;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.Getter;
import lombok.Setter;

import java.util.concurrent.CountDownLatch;
//减法计数器
public class CountDownLatchDemo {
    public static void main(String[] args) throws InterruptedException {
        CountDownLatch countDownLatch = new CountDownLatch(6);

        for (int i = 1; i <= 6; i++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "\t 国，被灭！");
                countDownLatch.countDown();
            }, CountryEnum.forEach_CountryEnum(i).getCountryName()).start();
        }
        countDownLatch.await();
        System.out.println(Thread.currentThread().getName() + "\t 秦国一统天下。");



    }

    private static void closeDoor() throws InterruptedException {
        //总数是六, 必须要执行任务的时候使用
        CountDownLatch countDownLatch = new CountDownLatch(6);
        for (int i = 1; i < 7; i ++) {
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName() + "go out!");
                //数量减一
                countDownLatch.countDown();
            }, String.valueOf(i)).start();


        }


        //等待计数器归零，然后再向下执行，确保全部跑完才进行下面的关门输出
        countDownLatch.await();

        System.out.println("close door！");
    }
}
@AllArgsConstructor
@Getter
enum CountryEnum {
    ONE(1, "齐"), TWO(2, "楚"), THREE(3, "燕"),
    FOUR(4, "赵"), FIVE(5, "魏"), SIX(6, "韩");

    private Integer id;
    private String countryName;

    public static CountryEnum forEach_CountryEnum(int index) {
        CountryEnum[] values = CountryEnum.values();
        for (CountryEnum value : values) {
            if (index == value.getId()) {
                return value;
            }
        }
        return null;
    }




}

```



## CyclicBarrier

加法计数器

> - 允许一组线程全部等待彼此达到共同屏障点的同步辅助。循环阻塞在涉及固定大小的线程方的程序中很有用，这些线程必须偶尔等待彼此。屏障被称为*循环*  ，因为它可以在等待的线程被释放之后重新使用。
> - A `CyclicBarrier`支持一个可选的[`Runnable`](../../../java/lang/Runnable.html)命令，每个屏障点运行一次，在派对中的最后一个线程到达之后，但在任何线程释放之前。  在任何一方继续进行之前，此*屏障操作*对更新共享状态很有用。 



```java
package com.pika.add;

import java.util.concurrent.BrokenBarrierException;
import java.util.concurrent.CyclicBarrier;

//加法计数器
public class CyclicBarrierDemo {
    public static void main(String[] args) {

        CyclicBarrier cyclicBarrier = new CyclicBarrier(7, () -> {
            System.out.println("召唤神龙成功");
        });

        for (int i = 1; i <= 7; i ++) {
            final int temp = i;
            //lambda怎样拿到a
            new Thread(() -> {
                System.out.println(Thread.currentThread().getName()+"已经收集了"+temp+"颗龙珠");

                //当计数到7时，触发
                try {
                    cyclicBarrier.await();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                } catch (BrokenBarrierException e) {
                    e.printStackTrace();
                }


            }).start();
        }
    }
}

```

## Semaphore

信号量

> 一个计数信号量。在概念上，信号量维持一组许可证。如果有必要，每个[`acquire()`都会](../../../java/util/concurrent/Semaphore.html#acquire--)阻塞，直到许可证可用，然后才能使用它。每个[`release()`](../../../java/util/concurrent/Semaphore.html#release--)添加许可证，潜在地释放阻塞获取方。但是，没有使用实际的许可证对象;`Semaphore`只保留可用数量的计数，并相应地执行。
>
> 信号量通常用于限制线程数，而不是访问某些（物理或逻辑）资源。  例如，这是一个使用信号量来控制对一个项目池的访问的类： 
>
> ```java
> class Pool { 
> 	private static final int MAX_AVAILABLE = 100; 
> 	private final Semaphore available = new Semaphore(MAX_AVAILABLE, true); 
> 	public Object getItem() throws InterruptedException { 
> 		available.acquire(); 
> 		return getNextAvailableItem(); 
> 	} 
> 	public void putItem(Object x) { 
> 		if (markAsUnused(x)) 
> 			available.release(); 
> 	} 
> 	// Not a particularly efficient data structure; just for demo 
>  protected Object[] items = ... whatever kinds of items being managed 
>  protected boolean[] used = new boolean[MAX_AVAILABLE]; 
>  protected synchronized Object getNextAvailableItem() { 
>      for (int i = 0; i < MAX_AVAILABLE; ++i) { 
>          if (!used[i]) { 
>              used[i] = true; 
>              return items[i]; 
>          } 
>      } 
>      return null; // not reached 
>  } 
>  protected synchronized boolean markAsUnused(Object item) { 
>      for (int i = 0; i < MAX_AVAILABLE; ++i) { 
>          if (item == items[i]) {
>              if (used[i]) { 
>                  used[i] = false; 
>                  return true; 
>              } else return false; 
>          } 
>      } 
>      return false; 
>  } 
> } 
> ```
>
> 在获得项目之前，每个线程必须从信号量获取许可证，以确保某个项目可用。  当线程完成该项目后，它将返回到池中，并将许可证返回到信号量，允许另一个线程获取该项目。 请注意，当[调用`acquire()`](../../../java/util/concurrent/Semaphore.html#acquire--)时，不会保持同步锁定，因为这将阻止某个项目返回到池中。  信号量封装了限制对池的访问所需的同步，与保持池本身一致性所需的任何同步分开。 
>
> 信号量被初始化为一个，并且被使用，使得它只有至多一个允许可用，可以用作互斥锁。  这通常被称为*二进制信号量* ，因为它只有两个状态：一个许可证可用，或零个许可证可用。  当以这种方式使用时，二进制信号量具有属性（与许多[`Lock`](../../../java/util/concurrent/locks/Lock.html)实现不同），“锁”可以由除所有者之外的线程释放（因为信号量没有所有权概念）。  这在某些专门的上下文中是有用的，例如死锁恢复。 
>
> 此类的构造函数可选择接受*公平*参数。  当设置为false时，此类不会保证线程获取许可的顺序。 特别是，  *闯入*是允许的，也就是说，一个线程调用[`acquire()`](../../../java/util/concurrent/Semaphore.html#acquire--)可以提前已经等待线程分配的许可证-在等待线程队列的头部逻辑新的线程将自己。  当公平设置为真时，信号量保证调用[`acquire`](../../../java/util/concurrent/Semaphore.html#acquire--)方法的线程被选择以按照它们调用这些方法的顺序获得许可（先进先出;  FIFO）。 请注意，FIFO排序必须适用于这些方法中的特定内部执行点。  因此，一个线程可以在另一个线程之前调用`acquire`  ，但是在另一个线程之后到达排序点，并且类似地从方法返回。 另请注意， [未定义的`tryAcquire`](../../../java/util/concurrent/Semaphore.html#tryAcquire--)方法不符合公平性设置，但将采取任何可用的许可证。 
>
> 通常，用于控制资源访问的信号量应该被公平地初始化，以确保线程没有被访问资源。  当使用信号量进行其他类型的同步控制时，非正常排序的吞吐量优势往往超过公平性。 
>
> 本课程还提供了方便的方法， [一次`acquire`](../../../java/util/concurrent/Semaphore.html#acquire-int-)和[`release`](../../../java/util/concurrent/Semaphore.html#release-int-)多个许可证。  当没有公平地使用这些方法时，请注意增加无限期延期的风险。 
>
> 内存一致性效应：在另一个线程中[成功](package-summary.html#MemoryVisibility)执行“获取”方法（如`acquire()`之前，调用“释放”方法之前的线程中的操作，例如`release()`  [*happen-before*](package-summary.html#MemoryVisibility)  。 



```java
package com.pika.add;

import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;

public class SemaphoreDemo {
    public static void main(String[] args) {

        // 线程数量，停车位
        Semaphore semaphore = new Semaphore(3);

        for (int i = 1; i <= 6; i ++) {
            new Thread(() -> {
                //每个acquire()都会阻塞，直到许可证可用，然后才能使用它

                try {
                    semaphore.acquire();
                    System.out.println(Thread.currentThread().getName() + "抢到车位");
                    TimeUnit.SECONDS.sleep(2);
                    System.out.println(Thread.currentThread().getName() + "离开车位");
                } catch (Exception e) {
                    e.printStackTrace();
                } finally {
                    //每个release()添加许可证，潜在地释放阻塞获取方
                    semaphore.release();
                }

                
            }, String.valueOf(i)).start();
        }
    }
}

```

原理：

semaphore.acquire(); 获得，假设已经满了，等待，等待被释放为止！

semaphore.release(); 释放，会将当前的信号量释放+1，然后唤醒等待的线程！

作用：多个共享资源互斥的使用！并发限流，控制最大线程数



# BlockingQueue（阻塞队列）

> 队列
>
> 先进先出的数据结构
>
> **阻塞**
>
> > 当阻塞队列为空时，从队列中获取元素的操作将被阻塞
> >
> > 当阻塞队列是满时，往队列里添加元素的操作将会被阻塞
> >
> > 试图从空的阻塞队列中获取元素的线程将会被阻塞，直到其它线程往空的队列插入新的元素。
> >
> > 试图往已满的队列中添加新元素的线程同样也会被阻塞，直到其它线程从队列中移除一个或者多个元素或者完全清空队列后使队列重新变的空闲起来并后续新增
>
> **为什么需要BlockingQueue**
>
> > 我们不需要关心什么时候需要阻塞线程，什么时候需要唤醒线程，因为这一切BlockingQueue都给你一手包办了
> >
> > 在concurrent包发布以前，在多线程环境下，我们每个程序员都 **必须去自己控制这些细节，尤其是还要兼顾效率呵线程安全**， 而这会给我们的程序带来不小的复杂度。

## 阻塞队列的种类	

> ArrayBlockingQueue：由数组结构组成的有界阻塞队列。
>
> LinkedBlockingQueue：由链表结构组成的有界（但是默认大小为Integer.MAX_VALUE）的阻塞队列。
>
> SynchronousQueue：不存储元素的阻塞队列，也即单个元素的队列。
>
> PriorityBlockingQueue：支持优先级排序的无界阻塞队列。
>
> DelayQueue：使用优先级队列实现的延迟无界阻塞队列。
>
> LinkedTransferQueue：由链表结构组成的无界阻塞队列。
>
> LinkedBlockingDeque：由链表结构组成的双向阻塞队列。



阻塞队列

> All Superinterfaces: 
> Collection <E>， Iterable <E>， Queue <E> 
> All Known Subinterfaces: 
> BlockingDeque <E>， TransferQueue <E> 
> 所有已知实现类： 
> ArrayBlockingQueue ， DelayQueue ， LinkedBlockingDeque ， LinkedBlockingQueue ， LinkedTransferQueue ， PriorityBlockingQueue ， SynchronousQueue

BlockingQueue不是新的东西

![image-20200817111720959](D:/玉/MD/皮卡JUC/images/image-20200817111720959.png)

使用情景：多线程并发处理、线程池

## BlockingQueue的核心方法

添加、移除

**四组API**

|     方式     | 抛出异常  | 不会抛出异常 | 阻塞等待 |           超时等待            |
| :----------: | :-------: | :----------: | :------: | :---------------------------: |
|     添加     |   add()   |   offer()    |  put()   | offer(o, timeout, TimeUnit.*) |
|     移除     | remove()  |    poll()    |  take()  |   poll(timeout, TimeUnit.*)   |
| 查看队列首位 | element() |    peek()    |    -     |               -               |

* 抛出异常

  ```java
  /**
       * 抛出异常
       */
      public static void test1() {
          //队列大小
          ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
          System.out.println(blockingQueue.add("a"));
          System.out.println(blockingQueue.add("b"));
          System.out.println(blockingQueue.add("c"));
  
          //java.lang.IllegalStateException: Queue full
  //        System.out.println(blockingQueue.add("d"));
          System.out.println(blockingQueue.remove());
          System.out.println(blockingQueue.remove());
          System.out.println(blockingQueue.remove());
  
          //java.util.NoSuchElementException
          System.out.println(blockingQueue.remove());
  
  
      }
  ```

  ![image-20200928152216503](.\images\image-20200928152216503.png) 

* 不会抛出异常返回布尔值

  ```java
  /**
       * 不抛出异常
       */
      public static void test2() {
          ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
          System.out.println(blockingQueue.offer("a"));
          System.out.println(blockingQueue.offer("b"));
          System.out.println(blockingQueue.offer("c"));
  
          System.out.println(blockingQueue.offer("d"));
  
  
          System.out.println(blockingQueue.poll());
          System.out.println(blockingQueue.poll());
          System.out.println(blockingQueue.poll());
  
          System.out.println(blockingQueu
                             e.poll());
      }
  ```

  ![image-20200928152313005](.\images\image-20200928152313005.png) 


* 阻塞等待

  ```java
  /**
       * 等待，阻塞（一直阻塞）
       */
      public static void test3() throws InterruptedException {
          ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
          blockingQueue.put("a");
          blockingQueue.put("b");
          blockingQueue.put("c");
  
  //        blockingQueue.put("d");
  
  
          System.out.println(blockingQueue.take());
          System.out.println(blockingQueue.take());
          System.out.println(blockingQueue.take());
  
          System.out.println(blockingQueue.take());
  
  
      }
  ```

  ![image-20200928152424265](.\images\image-20200928152424265.png) 

* 超时等待

  ```java
   /**
       * 等待，阻塞（等待超时）
       */
      public static void test4() throws InterruptedException {
          ArrayBlockingQueue blockingQueue = new ArrayBlockingQueue<>(3);
          System.out.println(blockingQueue.offer("a"));
          System.out.println(blockingQueue.offer("b"));
          System.out.println(blockingQueue.offer("c"));
          //两秒后超时失败
          System.out.println(blockingQueue.offer("d",2, TimeUnit.SECONDS));
  
  
          System.out.println(blockingQueue.poll());
          System.out.println(blockingQueue.poll());
          System.out.println(blockingQueue.poll());
  
          System.out.println(blockingQueue.poll(2, TimeUnit.SECONDS));
  
      }
  ```

  ![image-20200928152528212](.\images\image-20200928152528212.png) 



## SychronousQueue

SychronousQueue没有容量

与其他BlockingQueue不同，SynchronousQueue是一个不存储元素的BlockingQueue。

每一个put操作必须要等待一个take操作，否则不能继续添加元素，反之亦然。



```java
package com.pika.bq;

import java.util.concurrent.SynchronousQueue;
import java.util.concurrent.TimeUnit;

/**
 * 同步队列
 * 和其它的BlockingQueue不一样，SynchronousQueue 不存储元素
 * 如果向里面put了一个元素，必须从里面取出来，否则不能在put进去值
 */
public class SychronousQueueDemo {
    public static void main(String[] args) {
        //同步队列
        SynchronousQueue<String> synchronousQueue = new SynchronousQueue<String>();

        new Thread(() -> {
            try {
                System.out.println(Thread.currentThread().getName() + "put 1");
                synchronousQueue.put("1");
                System.out.println(Thread.currentThread().getName() + "put 2");
                synchronousQueue.put("2");
                System.out.println(Thread.currentThread().getName() + "put 3");
                synchronousQueue.put("3");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "T1").start();

        new Thread(() -> {
            try {
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + "get " + synchronousQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + "get " + synchronousQueue.take());
                TimeUnit.SECONDS.sleep(3);
                System.out.println(Thread.currentThread().getName() + "get " + synchronousQueue.take());
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "T2").start();

    }
}

```



## 用法案例

线程池，消息中间件

### 生产者消费者

#### 传统版

```java
package com.pika.pc;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author Pika
 * @create 2020/9/28
 * @since 1.0.0
 * 题目： 一个初始值为0的变量，两个线程对其交替操作，一个加1一个减1，来5轮
 *
 * 线程   操作(方法)      资源类
 * 判断   干活             通知
 * 防止虚假唤醒机制
 *
 */
public class ProductConsumer_TraditionDemo {
    public static void main(String[] args) {
        ShareData shareData = new ShareData();

        new Thread(() -> {
            for (int i = 0; i <= 5; i++) {
                try {
                    shareData.increment();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "T1").start();

        new Thread(() -> {
            for (int i = 0; i <= 5; i++) {
                try {
                    shareData.decrement();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }, "T2").start();
    }
}

class ShareData {
    private int number = 0;
    private Lock lock = new ReentrantLock();
    private Condition condition1 = lock.newCondition();

    public void increment() throws InterruptedException {
        lock.lock();
        try {
            //1.判断
            while (number != 0) {
                //2.等待不能生产
                condition1.await();
            }
            //2.生产
            number ++;
            System.out.println(Thread.currentThread().getName() + "\t生产线程\t" + number);
            //3.通知唤醒
            condition1.signalAll();
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }

    }


    public void decrement() throws InterruptedException {
        lock.lock();
        try {
            //1.判断
            while (number == 0) {
                //2.等待不能生产
                condition1.await();
            }
            //2.生产
            number --;
            System.out.println(Thread.currentThread().getName() + "\t消费线程\t" + number);
            condition1.signalAll();
        }catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }

    }


}

```

#### BlockingQueue版

```java
package com.pika.pc;

import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;



/**
 * @author Pika
 * @create 2020/9/28
 * @since 1.0.0
 * volatile/CAS/atomicInteger/BlockingQueue/线程交互
 */
public class ProducerConsumer_BlockQueueDemo {
    public static void main(String[] args) throws Exception {
        MyResource myResource = new MyResource(new ArrayBlockingQueue<>(10));
        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "\t 生产线程启动");
            try {
                myResource.myProducer();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Producer").start();

        new Thread(() -> {
            System.out.println(Thread.currentThread().getName() + "\t 消费线程启动");
            try {
                myResource.myConsumer();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }, "Consumer").start();


        try { TimeUnit.SECONDS.sleep(5); } catch (InterruptedException e) { e.printStackTrace(); }
        System.out.println();
        System.out.println("5秒钟时间到， 叫停生产");
        myResource.stop();
    }
}

class MyResource {
    private volatile boolean FLAG = true;//默认开启，生产+消费
    private AtomicInteger atomicInteger = new AtomicInteger();

    BlockingQueue<String> blockingQueue = null;

    public MyResource(BlockingQueue<String> blockingQueue) {
        this.blockingQueue = blockingQueue;
        System.out.println(blockingQueue.getClass().getName());
    }

    public void myProducer() throws InterruptedException {
        String data = null;
        boolean retValue;
        while (FLAG) {
            data = atomicInteger.incrementAndGet() + "";
            retValue = blockingQueue.offer(data, 2L, TimeUnit.SECONDS);
            if (retValue) {
                System.out.println(Thread.currentThread().getName() + "\t数据：" + data + "\t插入队列成功");
            } else {
                System.out.println(Thread.currentThread().getName() + "\t数据：" + data + "\t插入队列失败");
            }
            try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }

        }

        System.out.println(Thread.currentThread().getName() + "\t 大老板叫停，生产动作结束");
    }

    public void myConsumer() throws InterruptedException {
        String result = null;
        while (FLAG) {
            result = blockingQueue.poll(2L, TimeUnit.SECONDS);
            if (result == null || result.equalsIgnoreCase("")) {
                FLAG = false;
                System.out.println(Thread.currentThread().getName() + "\t 超过两秒钟没有取到数据，消费退出");
                return;
            }
            System.out.println(Thread.currentThread().getName() + "\t 消费队列成功" + result);
        }
    }

    public void stop() throws Exception {
        this.FLAG = false;
    }
}

```





## Synchronized和ReentrantLock的区别

> ```
> 题目：synchronized和lock有什么区别？用新的lock有什么好处？
> *1.原始构成
>   synchronized是关键字属于JVM层面
> *      monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象，只有在同步块或方法中才能调wait/notify等方法
> *      monitorexit
> *  lock是具体类（java.util.concurrent.locks.Lock）是api层面的锁
> *
> * 2.使用方法
> *  synchronized不需要用户去手动释放锁，当synchronized代码执行完毕后系统会自动让线程释放锁的占用
> *  ReentrantLock则需要用户去手动释放锁，如果没有释放锁，就有可能出现死锁现象。需要lock()和unlock()配合try/finally语句块来完成
> *
> * 3.等待是否可中断
> *  synchronized不可中断，除非抛出异常或者正常运行完成
> *  ReentrantLock可中断
> *      1.设置超时方法 tryLock(Long timeout, TimeUnit unit)
> *      2.lockInterruptibilty()放代码块中，调用interrupt()方法可中断
> *
> * 4.加锁是否公平
> *  synchronized是非公平锁
> *  ReentrantLock两者都可以，默认非公平锁，构造方法可以传入boolean值，true为公平锁，flase为非公平锁
> *
> * 5.锁绑定多个条件Condition
> *  synchronized没有
> *  ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随即唤醒一个线程要么唤醒全部
> ```



```java
package com.pika.lock;

import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

/**
 * @author Pika
 * @create 2020/9/28
 * @since 1.0.0
 *
 * 题目：synchronized和lock有什么区别？用新的lock有什么好处？
 * 1.原始构成
 *  synchronized是关键字属于JVM层面
 *      monitorenter（底层是通过monitor对象来完成，其实wait/notify等方法也依赖于monitor对象，只有在同步块或方法中才能调wait/notify等方法
 *      monitorexit
 *  lock是具体类（java.util.concurrent.locks.Lock）是api层面的锁
 *
 * 2.使用方法
 *  synchronized不需要用户去手动释放锁，当synchronized代码执行完毕后系统会自动让线程释放锁的占用
 *  ReentrantLock则需要用户去手动释放锁，如果没有释放锁，就有可能出现死锁现象。需要lock()和unlock()配合try/finally语句块来完成
 *
 * 3.等待是否可中断
 *  synchronized不可中断，除非抛出异常或者正常运行完成
 *  ReentrantLock可中断
 *      1.设置超时方法 tryLock(Long timeout, TimeUnit unit)
 *      2.lockInterruptibilty()放代码块中，调用interrupt()方法可中断
 *
 * 4.加锁是否公平
 *  synchronized是非公平锁
 *  ReentrantLock两者都可以，默认非公平锁，构造方法可以传入boolean值，true为公平锁，flase为非公平锁
 *
 * 5.锁绑定多个条件Condition
 *  synchronized没有
 *  ReentrantLock用来实现分组唤醒需要唤醒的线程们，可以精确唤醒，而不是像synchronized要么随即唤醒一个线程要么唤醒全部
 *
 *
 *  题目：多线程按顺序调用，实现A->B->C三个线程启动，要求如下：
 *  AA打印5次，BB打印10次，CC打印15次
 *  紧接着
 *  AA打印5次，BB打印10次，CC打印15次
 *  。。。
 *  来10轮
 *
 *
 */
public class SyncAndReentrantLock {
    public static void main(String[] args) {
        ShareResource shareResource = new ShareResource();
        new Thread(() -> {
            for (int i = 1; i <= 10 ; i++) {
                shareResource.print("A", 5);
            }
        }, "T1").start();
        new Thread(() -> {
            for (int i = 1; i <= 10 ; i++) {
                shareResource.print("B", 10);
            }
        }, "T2").start();
        new Thread(() -> {
            for (int i = 1; i <= 10 ; i++) {
                shareResource.print("C", 15);
            }
        }, "T3").start();
    }
}

class ShareResource {
    private int number = 1;//A:1, B:2, C:3
    private Lock lock = new ReentrantLock();
    private Condition c1 = lock.newCondition();
    private Condition c2 = lock.newCondition();
    private Condition c3 = lock.newCondition();


    public void print(String info, int times) {
        if (times == 5) {
            lock.lock();
            try {
                //1判断
                if (number != 1) {
                    c1.await();
                }
                //2干活
                for (int i = 1; i <= times; i++) {
                    System.out.println(Thread.currentThread().getName() + "\t" + info);
                }
                number = 2;
                //3.通知
                c2.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        } else if (times == 10) {
            lock.lock();
            try {
                //判断
                if (number != 2) {
                    c2.await();
                }
                for (int i = 1; i <= times; i++) {
                    System.out.println(Thread.currentThread().getName() + "\t" + info);
                }
                number = 3;
                c3.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        } else if (times == 15) {
            lock.lock();
            try {
                //判断
                if (number != 3) {
                    c3.await();
                }
                for (int i = 1; i <= times; i++) {
                    System.out.println(Thread.currentThread().getName() + "\t" + info);
                }
                number = 1;
                c1.signal();
            } catch (Exception e) {
                e.printStackTrace();
            } finally {
                lock.unlock();
            }
        }


    }
}

```





# Callable接口

![image-20200816180757638](.\images\image-20200816180757638.png)

* 可以有返回值

* 可以抛出异常
* 方法不同，run() / call()

> 代码测试

![image-20200816183325068](.\images\image-20200816183325068.png)



```java
package com.pika.callable;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;

/**
 * @author Pika
 * @create 2020/9/29
 * @since 1.0.0
 */
public class CallableDemo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //两个线程，一个主线程，一个是AA futureTask
        FutureTask<Integer> futureTask = new FutureTask<>(new MyThread2());
         new Thread(futureTask, "AA").start();
         new Thread(futureTask, "BB").start();


        int result1 = 100;

        int result2= 0;
        while (!futureTask.isDone()) {
            result2 = futureTask.get();

        }
//        int result2 = futureTask.get();//要求获得Callable线程的计算结果，如果没有计算完成，则等待计算完成，会造成阻塞。
        System.out.println("=======result：" +(result1 + result2));
    }
}



class MyThread2 implements Callable<Integer> {

    @Override
    public Integer call() throws Exception {
        System.out.println(Thread.currentThread().getName() + "********");
        try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }
        return 1024;
    }
}

```

# 线程池

## 线程池的优势

> 线程池做的工作主要是控制运行的线程的数量，**处理过程中将任务放入队列**，然后在线程创建后启动这些任务，**如果线程数量超过了最大数量的线程排队等候**，等其他线程执行完毕再从队列中取出任务来执行。
>
> 他的主要特点为：线程复用；控制最大并发数；管理线程。
>
> 
>
> 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
>
> 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
>
> 第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

## 线程池如何使用

java中线程池是通过Executor框架实现的，该框架中用到了Executor，Executors，ExecutorService，ThreadPoolExecutor这几个类。

### java自带的创建的线程池有五种

Executors.newScheduledThreadPool();

Executors.newWorkStealingPool(int);



Executors.newFixedThreadPool(int);

> 特点：
>
> 1 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待
>
> 2 newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize是相等的，它使用的是LinkedBlockingQueue;

Executors.newSingleThreadeExecutor();

> 特点
>
> 1 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有的任务按照指定顺序执行。
>
> 2 newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，它使用的是LinkedBlockingQueue

Executors.newCachedThreadPool();

> 特点
>
> 1 创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程
>
> 2 newCacheThreadPool将corePoolSize设置为0，将maximumPoolSize射中为Integer.Max_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。



## 线程池重要参数

### 七大参数

> int corePoolSize,//线程池中常驻核心线程数
>
> int maximumPoolSize,// 线程池能够容纳同时执行的最大线程数，此值必须大于等于1
>
> long keepAliveTime,// 多余的空闲线程的存活时间。当前的线程池数量超过corePoolSize时，当空闲时间达到keepAliveTime值时，多余空闲线程会被销毁直到只剩下corePoolSize个线程为止
>
> TimeUnit unit,// keepAliveTime的单位(超时单位）
>
> BlockingQueue<Runnable> workQueue,// 阻塞队列。任务队列，被提交但尚未被执行的任务
>
> ThreadFactory threadFactory,// 表示生成线程池中工作线程的线程工厂，用于创建线程，一般用默认的即可。
>
> RejectedExecutionHandler handler) {//拒绝策略，表示当队列满了并且工作线程大于等于线程池的最大线程数（maximumPoolSize）

```java
public static ExecutorService newSingleThreadExecutor() {
        return new FinalizableDelegatedExecutorService
            (new ThreadPoolExecutor(1, 1,
                                    0L, TimeUnit.MILLISECONDS,
                                    new LinkedBlockingQueue<Runnable>()));
    }

public static ExecutorService newFixedThreadPool(int nThreads) {
        return new ThreadPoolExecutor(nThreads, nThreads,
                                      0L, TimeUnit.MILLISECONDS,
                                      new LinkedBlockingQueue<Runnable>());
    }

public static ExecutorService newCachedThreadPool() {
        return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                      60L, TimeUnit.SECONDS,
                                      new SynchronousQueue<Runnable>());
    }

//本质调用了 ThreadPoolExecutor
public ThreadPoolExecutor(int corePoolSize,//核心线程池大小
                              int maximumPoolSize,// 最大核心线程池大小
                              long keepAliveTime,// 超时了，没有人调用就会释放
                              TimeUnit unit,// 超时单位
                              BlockingQueue<Runnable> workQueue,// 阻塞队列
                              ThreadFactory threadFactory,// 线程工厂，创建线程的，一般不用动
                              RejectedExecutionHandler handler) {//拒绝策略
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.acc = System.getSecurityManager() == null ?
                null :
                AccessController.getContext();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
```



## 线程池底层工作原理



> 1.在创建了线程池后，等待提交过来的任务请求。
>
> 2.当调用execute()方法添加一个请求任务时，线程池会做如下判断
>
> > 2.1 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；
> >
> > 2.2 如果正在运行的线程数量等于corePoolSize，但是任务队列没有满，将这个任务放入队列
> >
> > 2.2 如果正在运行的线程数量大于等于corePoolSize，小于maximumPoolSize，且任务队列满了，
> >
> > 那么创建一个非核心线程立刻运行这个任务。
> >
> > 2.3 如果正在运行的线程数量等于maximumPoolSize，那么线程池会启动饱和拒绝策略来执行相应的操作
>
> 3.当一个线程完成任务时，它会从任务队列中取下一个任务来执行
>
> 4.当一个线程闲置时间超过keepAliveTime时，线程池会判断，如果当前运行的线程数超过corePoolSize，那么这个线程将被销毁。
>
> 所以线程池所有任务完成后，线程池数量会收缩到corePoolSize（核心线程数）的大小







## 线程池的拒绝策略

四种拒绝策略

>  * new ThreadPoolExecutor.AbortPolicy()//默认，直接抛出RejectedExecutionException异常阻止系统正常运行。
>  * new ThreadPoolExecutor.CallerRunsPolicy()//“调用者运行”一种调节机制，该策略既不会抛弃任务，也不会抛出异常，而是将某些任务退回到调用者。
>  * new ThreadPoolExecutor.DiscardPolicy()//直接丢弃任务，不予以任何处理也不抛出异常；如果允许任务丢失，这时最好的一种方案。
>  * new ThreadPoolExecutor.DiscardOldestPolicy()//抛弃队列中等待最久的任务，然后把当前任务加入队列，并再次尝试提交当前任务。

以上拒绝策略均实现了`RejectedExecutionHandler`接口







## 线程池合理设置参数

尽量不使用java自带的Executors.创建，因为

FixedThreadPool和SingleThreadPool任务队列长度为默认的Integer.MAX_VALUE,可能会堆积大量请求导致OOM

CacheThreadPool和ScheduledThreadPool允许创建的线程数最大为Integer.MAX_VALUE，可能会创建大量的线程从而导致OOM



### 合理线程数配置



* CPU密集型

  * > CPU密集的意思是该任务需要大量的运算，而没有阻塞，CPU一直在全速运行
    >
    > CPU密集任务只有在真正的多核CPU上才能得到加速（通过多线程）
    >
    > 而在单核CPU上，无论你开几个线程都无法得到加速，因为CPU的运算能力是固定的
    >
    > CPU密集型任务一般配置尽可能少的线程数
    >
    > 一般公式：
    >
    > **CPU核数 + 1个线程**

* IO密集型

  * > 由于IO密集型任务并不是一直在执行任务，则应配置尽可能多的线程数：
    >
    > **CPU核数 * 2**

  * > IO密集型，即该任务需要大量阻塞，在单线程上运行IO密集型任务会导致浪费大量的CPU时间在阻塞上。
    >
    > 所以IO密集型任务中使用多线程可以大大加速程序的运行速度，即使在单核CPU上，也可以实现加速，这种加速主要是利用了被了浪费掉的阻塞等待的时间。
    >
    > 参考公式 ： 
    >
    > **CPU核数 / (1 - 阻塞系数)			阻塞系数在0.8~0.9之间**		
    >
    > **比如说8核的CPU： 8 / (1 - 0.9) = 80**





### 手动写一个线程池

```java
package com.pika.pool;

import java.util.concurrent.*;

/**
 * @author Pika
 * @create 2020/9/29
 * @since 1.0.0
 * 第四种获得/使用java多线程的方式 线程池
 *
 * 第一种继承Thread类
 * 第二种实现Runnable接口
 * 第三种实现Callable接口有返回值
 *
 *自己定义一个线程池
 * 核心数为2，最大线程数为5
 */
public class MyThreadPool {
    public static void main(String[] args) {
        System.out.println(Runtime.getRuntime().availableProcessors());
        ExecutorService threadPool =
                new ThreadPoolExecutor(
                        2,
                        5,
                        1L,
                        TimeUnit.SECONDS,
                        new LinkedBlockingQueue<>(3),
                        Executors.defaultThreadFactory(),
                        new ThreadPoolExecutor.DiscardPolicy()
                );

        try {
            for (int i = 1; i <= 10; i++) {
                threadPool.execute(() -> {
                    System.out.println(Thread.currentThread().getName() + "\t 办理业务");
                });
            }
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            threadPool.shutdown();
        }

    }
}

```



# 死锁



> 死锁是指两个或两个以上线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力干涉，那么它们都将无法推进下去；如果系统资源充足，线程的资源请求都能得到满足，那么死锁的发生概率就会很低，否则就会因为争夺有限的资源而陷入死锁。
>
> 产生原因
>
> > 系统资源不足
> >
> > 进程运行推进的顺序不合适
> >
> > 资源分配不当





## 代码演示

```java
package com.pika.dl;

import lombok.AllArgsConstructor;

import java.util.concurrent.TimeUnit;

/**
 * @author Pika
 * @create 2020/9/30
 * @since 1.0.0
 *
 * 死锁是指两个或两个以上线程在执行过程中，
 * 因争夺资源而造成的一种互相等待的现象，
 * 若无外力干涉，那么它们都将无法推进下去
 *
 */
public class DeadLockDemo {
    public static void main(String[] args) {
        String lock1 = "lockA";
        String lock2 = "lockB";

        new Thread(new HoldLockThread(lock1, lock2), "T1").start();
        new Thread(new HoldLockThread(lock2, lock1), "T2").start();
    }
}

@AllArgsConstructor
class HoldLockThread implements Runnable {
    private String l1;
    private String l2;


    @Override
    public void run() {
        synchronized (l1) {
            System.out.println(Thread.currentThread().getName() + "\t 自己持有：" + l1 + "尝试获得：" + l2);
            try { TimeUnit.SECONDS.sleep(2); } catch (InterruptedException e) { e.printStackTrace(); }

            synchronized (l2) {
                System.out.println(Thread.currentThread().getName() + "\t 自己持有：" + l2 + "尝试获得：" + l1);
            }
        }



    }
}

```



## 整明并解决



* 使用jps定位进程号

  * jsp -l	定位进程号

    ![image-20200930221314793](.\images\image-20200930221314793.png) 

* 使用jstack进程号查看信息

  * jstack 进程号

    ![image-20200930221508306](.\images\image-20200930221508306.png)

  





























































# 遇到过的异常类

## 并发修改异常

**ArrayList并发修改**

> 故障现象
>
> > java.util.ConcurrentModificationException
>
> 导致原因
>
> > 集合类并发争抢修改导致的：一个线程正在修改，另一个线程也想要修改并过来抢夺，导致数据不一致，并发修改异常。
>
> 解决方案
>
> > 1.List<String> list = new Vector();
> >
> > 2.List<String> list = Collections.synchronizedList(new ArrayList<>());
> >
> > 3.List<String> list = new CopyOnWriteArrayList();
> >
> > > 写时复制
> > >
> > > CopyOnWrite容器即写时复制容器。往一个容器添加元素的时候，不直接往当前容器Object[]中添加，而是先拷贝当前容器Object[]，复制出一个新的容器Object[] newElements，然后在新的新的容器newElements中添加元素，添加完元素后，将原容器的引用指向新的容器setArray(newElements); 这样做的好处是可以对CopyOnWrite进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite也是一种读写分离的思想，读和写在不同的容器中。
> > >
> > > ```java
> > > public boolean add(E e) {
> > >      final ReentrantLock lock = this.lock;
> > >      lock.lock();
> > >      try {
> > >          Object[] elements = getArray();
> > >          int len = elements.length;
> > >          Object[] newElements = Arrays.copyOf(elements, len + 1);
> > >          newElements[len] = e;
> > >          setArray(newElements);
> > >          return true;
> > >      } finally {
> > >          lock.unlock();
> > >      }
> > >  }
> > > ```
> > >
> > > 
>
> 优化建议
>
> 































































